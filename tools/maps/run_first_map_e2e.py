#!/usr/bin/env python3
"""Run first-map end-to-end verification through the FastAPI map endpoints."""

from __future__ import annotations

import argparse
import json
import os
from pathlib import Path
import sys


ROOT = Path(__file__).resolve().parents[2]
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))


def _read_json(path: Path) -> dict:
    return json.loads(path.read_text(encoding="utf-8"))


def main() -> int:
    parser = argparse.ArgumentParser(description="Run first map E2E pipeline checks")
    parser.add_argument("--town-id", default="oakville_e2e", help="Town id for publish flow")
    parser.add_argument(
        "--config-path",
        default="assets/templates/starter_town/customization.example.json",
        help="Customization config path",
    )
    parser.add_argument(
        "--db-path",
        default="data/vvalley_e2e.db",
        help="SQLite DB path for this check",
    )
    args = parser.parse_args()

    db_path = Path(args.db_path)
    if not db_path.is_absolute():
        db_path = (ROOT / db_path).resolve()
    db_path.parent.mkdir(parents=True, exist_ok=True)
    if db_path.exists():
        db_path.unlink()

    os.environ["VVALLEY_DB_PATH"] = str(db_path)

    from apps.api.vvalley_api.main import app
    from apps.api.vvalley_api.storage.map_versions import reset_backend_cache_for_tests
    from fastapi.testclient import TestClient

    reset_backend_cache_for_tests()
    client = TestClient(app)

    town_id = args.town_id
    town_dir = ROOT / "assets" / "maps" / "v_valley" / town_id
    town_dir.mkdir(parents=True, exist_ok=True)

    draft_map_path = town_dir / "draft.map.json"
    draft_nav_path = town_dir / "draft.nav.json"
    rebaked_nav_path = town_dir / "draft.rebaked.nav.json"

    print("[1/6] Listing templates...")
    resp = client.get("/api/v1/maps/templates")
    if resp.status_code != 200:
        print(f"FAIL templates list: {resp.status_code} {resp.text}")
        return 1
    template_ids = [r.get("template_id") for r in resp.json().get("templates", [])]
    if "starter_town" not in template_ids:
        print("FAIL templates list: starter_town not found")
        return 1

    print("[2/6] Scaffolding map from starter_town...")
    resp = client.post(
        "/api/v1/maps/templates/scaffold",
        json={
            "template_id": "starter_town",
            "town_id": town_id,
            "out_map_path": str(draft_map_path.relative_to(ROOT)),
            "out_nav_path": str(draft_nav_path.relative_to(ROOT)),
            "config_path": args.config_path,
            "validate_after": True,
        },
    )
    if resp.status_code != 200 or not resp.json().get("ok"):
        print(f"FAIL scaffold: {resp.status_code} {resp.text}")
        return 1

    print("[3/6] Validating scaffolded map...")
    resp = client.post(
        "/api/v1/maps/validate-file",
        json={"map_path": str(draft_map_path.relative_to(ROOT))},
    )
    if resp.status_code != 200 or not resp.json().get("ok"):
        print(f"FAIL validate: {resp.status_code} {resp.text}")
        return 1

    print("[4/6] Baking nav from scaffolded map...")
    resp = client.post(
        "/api/v1/maps/bake-file",
        json={
            "map_path": str(draft_map_path.relative_to(ROOT)),
            "out_path": str(rebaked_nav_path.relative_to(ROOT)),
            "allow_invalid": False,
        },
    )
    if resp.status_code != 200 or not resp.json().get("ok"):
        print(f"FAIL bake: {resp.status_code} {resp.text}")
        return 1

    print("[5/6] Publishing version...")
    resp = client.post(
        "/api/v1/maps/publish-version",
        json={
            "town_id": town_id,
            "map_path": str(draft_map_path.relative_to(ROOT)),
            "map_name": "starter_e2e",
            "notes": "Generated by run_first_map_e2e.py",
        },
    )
    if resp.status_code != 200 or not resp.json().get("ok"):
        print(f"FAIL publish: {resp.status_code} {resp.text}")
        return 1
    publish_payload = resp.json()
    version_number = int(publish_payload["version"]["version"])

    print("[6/6] Checking active version...")
    resp = client.get(f"/api/v1/maps/versions/{town_id}/active")
    if resp.status_code != 200:
        print(f"FAIL active version lookup: {resp.status_code} {resp.text}")
        return 1
    active = resp.json()["active"]
    if int(active["version"]) != version_number:
        print(
            f"FAIL active version mismatch: expected {version_number}, got {active['version']}"
        )
        return 1

    if not draft_map_path.exists() or not draft_nav_path.exists() or not rebaked_nav_path.exists():
        print("FAIL expected draft map/nav outputs missing")
        return 1

    # Sanity check that map has customization property applied.
    draft_map = _read_json(draft_map_path)
    prop_names = {str(p.get("name")) for p in draft_map.get("properties", [])}
    if "town_theme" not in prop_names:
        print("FAIL customization not applied: expected map property 'town_theme'")
        return 1

    print("OK first-map E2E passed")
    print(f"Town: {town_id}")
    print(f"Draft map: {draft_map_path}")
    print(f"Draft nav: {draft_nav_path}")
    print(f"Rebaked nav: {rebaked_nav_path}")
    print(f"Published version: v{version_number}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
